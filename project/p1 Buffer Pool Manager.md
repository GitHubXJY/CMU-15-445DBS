### Buffer Pool Manager 缓冲池管理器

在该项目中，为`BusTub DBMS`构建一个新的面向磁盘的存储管理器。这样的存储管理器假设数据库的主要存储位置在磁盘上。

该项目是在存储管理器中实现缓冲池。缓冲池负责在主内存和磁盘之间来回移动物理页，它允许DBMS支持大于系统可用内存量的数据库。缓冲池的操作对系统中的其它部分是透明的。系统通过其唯一标识符(`page_id_t`)向缓冲池请求页面，缓冲池从内存或磁盘中检索该页面后返回给系统。

项目的实现需要是线程安全的，多个线程将同时访问内部数据结构。

需要在存储管理器中实现三个组件：

* Extendible Hash Table 可扩展哈希表
* LRU-K Replacement Policy LRU-K置换算法
* Buffer Pool Manager Instance 缓冲池管理器实例

#### Task1 Extendible Hash Table

##### 1.1 可扩展哈希

[Extendible Hashing](https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/)
[2022 p1 Buffer Pool](https://blog.csdn.net/q2453303961/article/details/128153709?spm=1001.2014.3001.5502)

静态哈希（静态散列）要求桶的数目始终固定，那么在确定桶的数目和选择哈希函数时，如果桶的数目过小，随着数据量的增加，性能会降低；如果留有一定余量，又会带来空间的浪费；或者定期重组哈希索引结构，但开销大且耗时。为此，提出了几种动态哈希(dynamic hashing)技术，可扩展哈希(extendible hashing)便是其一。

可扩展哈希中的一些术语：

* **目录(Directories)**：目录存储指向桶的指针，每个目录都有一个唯一的`ID`，每次扩展时该ID都可能会发生变化。哈希函数返回目录ID，用于定位到合适的桶。目录数=2^全局深度。
* **桶(Buckets)**：桶用来存放数据。目录指向桶。如果桶的局部深度小于全局深度，则可能包含多个指向该桶的指针。注意区分桶的大小和局部深度的区别。
* **全局深度(Global Depth)**：对`key`哈希后得到二进制的数据，选取二进制数据的`D`个最低有效位作为作为目录ID。`D`就是全局深度，即全局深度=目录ID的位数。
* **局部深度(Loacl Depth)**：每个桶都有独立的局部深度（记作`L`），局部深度表示该桶中所有元素的`key`的哈希值的后`L`位是相等的。局部深度根据全局深度来决定发生溢出时要执行的操作。局部深度始终小于等于全局深度。
* **目录扩展(Directory Expansion)**：目录扩展发生在桶溢出时。当溢出桶的局部深度等于全局深度时，进行目录扩展。目录扩展将使哈希结构中的目录数加倍。
* **桶分裂(Bucket Splitting)**：当桶中的元素数量超过设定大小时，桶被分为两部分。

##### 1.2 任务实现

构建一个可扩展哈希表，该表使用无序存储桶来存储唯一的键值对。实现的哈希表必须支持插入和删除键/值的功能，而无需指定表的最大大小。实现的表需要根据需要逐渐增大，但不需要缩小它。

###### 1.2.1 Insert()

* s1 获取插入元素的`hash()`，取得到的二进制数的`目录的全局深度`个最低有效位，并将其与目录`dir_`进行匹配。得到匹配的目录所指向的桶的指针，即`dir_[i]`。
* s2 如果`dir_[i]`指向的桶已经存在待插入元素，则用新值覆盖旧值，并转到s5。
* s3 尝试插入元素，如果插入成功则转到s5。否则进行以下步骤：
* * 当前桶已满，进行桶溢出处理。判断当前桶的局部深度`local_depth_`和全局深度`golbal_depth_`的大小关系：
* * * c1：如果`local_depth_`等于`global_depth_`，则先进行目录扩展，再进行桶分裂。
* * * c2：如果`local_depth_`小于`global_depth_`，则只进行桶分裂。
* s4 桶溢出处理完成，转到s3 再次尝试插入元素。
* s5 插入元素完成。

**目录扩展**：将当前目录`dir_`的**目录项扩容一倍**，然后将**全局深度`global_depth_`的值加1**。假设扩容前`global_depth_=2`，则`size(dir_)=4`，扩容后`global_depth_=3`，`size(dir_)=8`。扩容后的新增的目录项`dir_[x] (x=4,5,6,7)`和目录项`dir_[x-4] (x-4=0,1,2,3)`指向同一个桶。因为(假设`x=5`)：`dir_[5]`对应的`key`的哈希值的低3位为`101`，低2位为`01`，`dir_[1]`对应的`key`的哈希值的低3位为`001`，低2位为`01`，也就是说，扩容后本该存储在`dir_[5]`中的元素在扩容前存储在`dir_[1]`中，所以这两个目录指向同一个桶。

任何时候任一桶的局部深度`local_depth_`都小于等于全局深度`global_depth_`。任一局部深度小于全局深度的桶都会被多个目录所指向，桶中存储的元素的`local_depth_`个最低有效位都相同；这多个目录的`local_depth_`个最低有效位都相同，但`global_depth_`个最低有效位都不相同。

**桶分裂**：**将要分裂的桶的局部深度`local_depth_`的值加1**，然后**新建一个新桶**，原先的桶称为旧桶。以`global_depth_=3`，`x=1`，分裂前`local_depth_=2`，分裂后`local_depth_=3`为例：之前`dir_[1]`指向的桶已满，新建一个新桶，**根据新的局部深度，判断哪些目录指针应该指向新桶并修改指向**（如`dir_[5]`之前指向的桶与`dir_[1]`相同，但现在应该指向新桶）。旧桶中的元素的`2`个最低有效位都相同，但`3`个最低有效位不一定相同，**桶分裂后对旧桶中的元素根据新的局部深度重新进行判断，分配到新桶(`101`)和旧桶(`001`)中**。

#### Task2 LRU-K Replacement Policy

##### 2.1 LRU-K

`缓存`是一种常见的空间换时间的做法，但缓存的大小不是无限制的，需要一种算法淘汰超出大小限制的缓存。LRU（Least Recently Used，最近最少使用）算法根据数据的历史访问记录来淘汰数据，其核心思想是“最近被访问过的数据，其在将来被访问的几率更大”。其实现原理是：维护一个`历史记录队列`（链表）保存每次访问的数据。新的访问数据插入到队列的头部；每当缓存命中（即缓存数据被访问）时将数据移动到队列的头部；当队列满时将淘汰队尾的数据。

LRU-K算法的主要目的是为了解决LRU算法可能会出现的`缓存污染`（和`预读失效`）问题，因此将“最近访问过一次”的判断标准扩展为“最近访问过K次”。只有访问次数达到`K`次的数据才会被缓存，因此需要对缓存数据的访问次数进行计数，并且访问记录不能无限记录，也需要使用替换算法进行替换，当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。相比LRU，LRU-K需要多维护一个`缓存队列`，当数据的访问次数达到K次的时候，才将数据索引从历史记录队列移动到缓存队列。缓存队列中的数据被访问后进行重新排序。

LRU-K算法将替换器的所有帧中后向k距离最大的那个帧驱逐。后向k距离的计算方式是当前时间戳与第k次访问时的时间戳之间的时间差。历史访问次数少于k次的帧被赋予+inf作为其后向k距离。当多个帧具有+inf后向k距离时，替换器将驱逐具有最早时间戳的那个帧。

`LRUKReplacer`的最大大小与缓冲池的大小相同，因为它包含`BufferPoolManager`中所有帧的占位符。但在任何给定时刻，替换器中并非所有的帧都是可驱逐的。`LRUKReplacer`的大小由可驱逐的帧的数量表示，`LRUKReplacer`被初始化为其中没有帧，只有当一个帧被标记为可驱逐时，替换器的size才会增大。

##### 2.2 任务实现

1. `Evict(frame_id_t* )`：与其它所有被`Replacer`跟踪的可驱逐的帧相比，驱逐具有最大后向k距离的那个，将帧ID存储在输出参数中并返回true，如果没有可驱逐的帧则返回false。

2. `RecordAccess(frame_id_t )`：记录在当前时间戳访问的帧的ID。当页面固定在(is pinned in)`BufferPoolManager`后调用此方法。

3. `Remove(frame_id_t )`：清楚和帧关联的所有历史访问记录。仅当在`BufferPoolManager`中删除页面时才调用此方法。

4. `SetEvictable(frame_id_t, bool set_evictable)`：此方法决定一个帧是否可驱逐，它还决定`LRUKReplacer`的大小。当页面的pin计数为0时，其对应的帧被标记为可驱逐，并且替换器的大小会增加。

5. `Size()`：返回当前位于`LRUKReplacer`中可驱逐的帧的数量。

#### Task3

##### 3.1

##### 3.2 任务实现
